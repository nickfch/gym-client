import React, { useState, useEffect, useCallback, useMemo } from 'react';
import { Exercise } from 'src/types/api-autogenerated';
import { useCompleteWorkoutMutation } from 'src/requests/hooks/useCompleteWorkoutMutation';
import { useGetWorkout } from 'src/requests/hooks/useGetWorkout';
import { WorkoutScreenState } from './WorkoutScreen.types';

type UserExercise = Exercise & { completed: boolean };

export const useWorkoutLogic = (workoutId: string) => {
  const { data, refetch, isLoading } = useGetWorkout(workoutId);
  const { mutate: completeWorkoutMutation } = useCompleteWorkoutMutation();
  const workoutCompleted = useMemo(() => false, [data]);

  const [selectedWorkout, setSelectedWorkout] =
    useState<WorkoutScreenState['selectedWorkout']>(null);

  // State for workout progress
  const [currentExerciseId, setCurrentExerciseId] =
    useState<WorkoutScreenState['currentExerciseId']>('');
  const [workoutInProgress, setWorkoutInProgress] =
    useState<WorkoutScreenState['workoutInProgress']>(false);
  const [workoutScore, setWorkoutScore] =
    useState<WorkoutScreenState['workoutScore']>(0);

  const [exercises, setExercises] = useState<UserExercise[]>(
    data?.data?.exercises?.map((ex) => ({
      ...(ex as unknown as Exercise),
      completed: false,
    })) || [],
  );

  const calculateWorkoutScore = useCallback(
    (completedIds: string[]) => {
      // Simple scoring algorithm - can be adjusted based on your needs
      const totalExercises = exercises.length;
      const completionPercentage = (completedIds.length / totalExercises) * 100;

      // Calculate score out of 100
      const newScore = Math.round(completionPercentage);
      setWorkoutScore(newScore);
    },
    [exercises, setWorkoutScore],
  );

  const startWorkout = () => {
    if (exercises.length === 0) {
      throw new Error('No exercises found for this workout');
    }
    setWorkoutInProgress(true);
    setCurrentExerciseId(exercises[0].documentId!);

    setExercises(
      exercises.map((ex) => ({
        ...ex,
        completed: false,
      })),
    );
  };

  const completeWorkout = useCallback(() => {
    completeWorkoutMutation(
      {
        workoutId,
      },
      {
        onSuccess(data) {
          setWorkoutInProgress(false);
          calculateWorkoutScore(
            exercises.filter((ex) => ex.completed).map((ex) => ex.documentId!),
          );
          refetch();
        },
      },
    );
    // Here you would typically send the workout results to your backend
  }, [
    completeWorkoutMutation,
    workoutId,
    setWorkoutInProgress,
    calculateWorkoutScore,
    exercises,
  ]);

  const toggleExerciseCompletion = useCallback(
    (exerciseId: string) => {
      setExercises((prevExercises) =>
        prevExercises.map((ex) =>
          ex.documentId === exerciseId
            ? { ...ex, completed: !ex.completed }
            : ex,
        ),
      );
    },
    [setExercises],
  );

  const moveToNextExercise = useCallback(() => {
    const currentIndex = exercises.findIndex(
      (ex) => ex.documentId === currentExerciseId,
    );
    if (currentIndex < exercises.length - 1) {
      setCurrentExerciseId(exercises[currentIndex + 1].documentId!);
    } else {
      // All exercises completed
      completeWorkout();
    }
  }, [exercises, currentExerciseId, setCurrentExerciseId, completeWorkout]);

  const refreshWorkout = useCallback(() => {
    completeWorkoutMutation(
      {
        workoutId,
        completed: false,
      },
      {
        onSuccess(data) {
          setWorkoutInProgress(false);
          setCurrentExerciseId('');
          refetch();
          setExercises(
            exercises.map((ex) => ({
              ...ex,
              completed: false,
            })),
          );
        },
      },
    );
  }, [
    completeWorkoutMutation,
    workoutId,
    setWorkoutInProgress,
    setCurrentExerciseId,
    setExercises,
  ]);

  useEffect(() => {
    if (data?.data?.exercises) {
      setExercises(
        data.data?.exercises.map<UserExercise>((ex) => ({
          ...(ex as unknown as Exercise),
          completed: false,
        })),
      );
    }
    if (data?.data) {
      setSelectedWorkout(data.data as any);
    }
  }, [data]);

  return {
    selectedWorkout,
    currentExerciseId,
    workoutInProgress,
    workoutCompleted,
    workoutScore,
    exercises,
    isLoading,
    startWorkout,
    completeWorkout,
    toggleExerciseCompletion,
    moveToNextExercise,
    refreshWorkout,
  };
};
